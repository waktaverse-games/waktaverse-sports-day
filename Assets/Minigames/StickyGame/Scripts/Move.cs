using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Move : MonoBehaviour
{
    [SerializeField] private float rotateSpeed; // 회전속도
    [SerializeField] private Vector2 curAxis; // 현재 회전 축 좌표
    [SerializeField] private int dir; // 1 : 시계반대방향, -1 : 시계방향

    [SerializeField] private List<Transform> backRunners; // 현재까지 associate한 backRunner들
    public bool isPlayer, isAssociated;

    private void Awake()
    {
        curAxis = Vector2.zero;
        dir = 1;

        backRunners = new List<Transform>();
    }

    private void Update()
    {
        if (isAssociated)
        {
            transform.RotateAround(curAxis, dir * Vector3.forward, Time.deltaTime * rotateSpeed);
            transform.rotation = Quaternion.Euler(0, 0, 0);
        }

        if (isPlayer && Input.GetButtonDown("Jump")) // Space Bar 입력시 방향 전환
        {
            curAxis = 2 * (Vector2)transform.position - curAxis; // 축 중심 변경
            dir *= -1;  // 축 방향 변경

            if (backRunners.Count > 0)
            {
                StartCoroutine(changeDirOfBackRunners(0));
            }
        }
    }

    private void OnTriggerEnter2D(Collider2D collider)
    {
        if (isPlayer)
        {
            if (collider.CompareTag("Runner"))
            {
                if (collider.GetComponent<Move>().isAssociated)
                {
                    print("GameOver");
                    SceneManager.LoadScene(SceneManager.GetActiveScene().name);
                }
                else
                {
                    Associate(collider);
                }
            }
            else if (collider.CompareTag("Outline"))
            {
                print("GameOver");
                SceneManager.LoadScene(SceneManager.GetActiveScene().name);
            }
        }
    }

    IEnumerator changeDirOfBackRunners(int idx) // backRunners의 방향을 차례대로 바꿔주는 함수
    {
        Vector3 prevAxis = curAxis;

        if (idx > 0) prevAxis = backRunners[idx - 1].GetComponent<Move>().curAxis;

        yield return new WaitForSeconds(60 / rotateSpeed);

        Move curRunner = backRunners[idx].GetComponent<Move>();

        // 방향 변경
        curRunner.curAxis = prevAxis;
        curRunner.dir *= -1;  // 축 방향 변경

        if (++idx < backRunners.Count) // 마지막 주자가 아닐 때까지 코루틴 반복
        {
            StartCoroutine(changeDirOfBackRunners(idx));
        }
    }
    private void Associate(Collider2D collider) // 충돌시 뒤 주자로 Associate
    {
        Move moveCS = collider.GetComponent<Move>();

        if (backRunners.Count == 0)
        {
            collider.transform.position = transform.position;
            moveCS.isAssociated = true;
            moveCS.curAxis = curAxis;
            moveCS.dir = dir;
            collider.transform.RotateAround(curAxis, dir * Vector3.forward, -60); // 30도만큼 이전에 위치
        }
        else
        {
            Move lastRunner = backRunners[backRunners.Count - 1].GetComponent<Move>();

            collider.transform.position = lastRunner.transform.position;
            moveCS.isAssociated = true;
            moveCS.curAxis = lastRunner.curAxis;
            moveCS.dir = lastRunner.dir;
            collider.transform.RotateAround(lastRunner.curAxis, lastRunner.dir * Vector3.forward, -60); // 30도만큼 이전에 위치
        }

        backRunners.Add(collider.transform);
    }
}
